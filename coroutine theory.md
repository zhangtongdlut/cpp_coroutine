# 协程理论

这是有关[C++ Coroutines TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf)——一个纳入C++20语言标准的新功能  系列文章的第一篇，在本系列中，我将介绍C++协程的底层机制如何工作，并展示如何使用它们来构建有用的高级抽象，如 [cppcoro](https://github.com/lewissbaker/cppcoro) 库里面提供的抽象。

在这篇文章中，我将描述函数和协程之间的差异，并提供一些有关它们支持的操作的理论。本文的目的是介绍一些基本概念，这些概念将有助于构建您对C++协程的思考方式。

## 协程是协程的函数

协程是允许暂停和恢复的函数，我将在下文中更详细解释这句话的含义，但在此之前我想先回顾一下"普通"C++函数的工作原理。

## “普通”函数

一个普通函数可以被认为具有两种操作：**调用**和**返回**(这里我把"抛出异常"宽泛地归结到**返回**操作)。

**调用**操作创建一个活动帧，暂停当前函数的执行并将执行转移到被调用函数的开头。

**返回**操作传递返回值给调用方，销毁活动帧然后在调用方调用点之后的位置恢复执行。

让我们进一步分析这些语义

### 活动帧

活动帧到底是什么？

可以将活动帧理解成一块内存：包含了一个函数调用的当前状态。状态包含传递给函数的参数和本地变量。

对于"普通"函数，活动帧也包含了返回地址 - 函数返回时将执行转移到指令的地址 - 以及调用方的活动帧的地址。你可以将这些信息一并视为描述函数调用的"延续(continuation)"。它们描述了当该函数完成时，哪个函数的哪个调用应该继续执行。

对于"普通"函数，活动帧有严格嵌套的生命周期。通常使用高效的内存分配数据结构 - 栈(stack)负责对活动帧的申请和释放。

当一个活动帧在栈上被申请的时候，一般被称为"栈帧"。

栈这个数据结构非常常见，以至于几乎所有CPU架构都有一个专用的寄存器，用于保存指向栈顶指针(x64 中的 rsp 寄存器)。

要为新的活动帧分配空间，只需要将该寄存器增加frame-size即可。要释放活动帧，只需要将寄存器减小frame-size即可。

### "调用"操作

当一个函数调用其他函数，调用方必须首先准备好挂起(暂停)。




