# 协程理论

这是有关[C++ Coroutines TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf)——一个纳入C++20语言标准的新功能  系列文章的第一篇，在本系列中，我将介绍C++协程的底层机制如何工作，并展示如何使用它们来构建有用的高级抽象，如 [cppcoro](https://github.com/lewissbaker/cppcoro) 库里面提供的抽象。

在这篇文章中，我将描述函数和协程之间的差异，并提供一些有关它们支持的操作的理论。本文的目的是介绍一些基本概念，这些概念将有助于构建您对C++协程的思考方式。

## 协程是协程的函数

协程是允许暂停和恢复的函数，我将在下文中更详细解释这句话的含义，但在此之前我想先回顾一下"普通"C++函数的工作原理。

## “普通”函数

一个普通函数可以被认为具有两种操作：**调用**和**返回**(这里我把"抛出异常"宽泛地归结到**返回**操作)。

**调用**操作创建一个活动帧，暂停当前函数的执行并将执行转移到被调用函数的开头。

**返回**操作传递返回值给调用方，销毁活动帧然后在调用方调用点之后的位置恢复执行。

让我们进一步分析这些语义

### 活动帧

活动帧到底是什么？

可以将活动帧理解成一块内存：包含了一个函数调用的当前状态。状态包含传递给函数的参数和本地变量。

对于"普通"函数，活动帧也包含了返回地址 - 函数返回时将执行转移到指令的地址 - 以及调用方的活动帧的地址。你可以将这些信息一并视为描述函数调用的"延续(continuation)"。它们描述了当该函数完成时，哪个函数的哪个调用应该继续执行。

对于"普通"函数，活动帧有严格嵌套的生命周期。通常使用高效的内存分配数据结构 - 栈(stack)负责对活动帧的申请和释放。

当一个活动帧在栈上被申请的时候，一般被称为"栈帧"。

栈这个数据结构非常常见，以至于几乎所有CPU架构都有一个专用的寄存器，用于保存指向栈顶指针(x64 中的 rsp 寄存器)。

要为新的活动帧分配空间，只需要将该寄存器增加frame-size即可。要释放活动帧，只需要将寄存器减小frame-size即可。

### "调用"操作

当一个函数调用其他函数，调用方必须首先准备好挂起(暂停)。

挂起操作通常包含：将cpu寄存器中的当前值保存到内存，以便当函数恢复执行时恢复
它们。调用方和被调用方会依据约定去协商谁来保存这些寄存器的值，但你仍可以把
它们当作调用操作的一部分。

调用方还将传递给被调用函数的所有参数存储到活动帧中，以便函数可以访问它们。

最后，调用者将恢复到调用者的地址写到新的活动帧中，并把执行转移到被调用函数
的开头。

在x86/x64架构中，这个最终的操作有自己的指令，称为call指令：将下一个指令的
地址写到栈顶，将栈寄存器的地址增加地址的大小，再跳转到指令操作数指定的地址。

### “返回”操作

当一个函数通过return语句返回时，函数首先将返回值(如果有的话)存储在调用方
可以访问到的地方。可以存储在调用方的活动帧或者被调用方的活动帧(对于跨越两
个活动帧边界的参数和返回值，这种区别可能有点模糊)。

然后函数这样销毁活动帧：
- 销毁返回点范围内的所有本地变量
- 销毁所有参数对象
- 释放活动帧使用的内存

最后，这样恢复调用方的执行：
- 通过将堆栈寄存器设置为指向调用方的活动帧并恢复可能被函数破坏的任何寄存器
来恢复调用方的活动帧。
- 跳转到“调用”操作期间存储的调用方恢复点。

注意，与“调用”操作一样，一些调用约定可能会将“返回”操作的指责划分在调用者
和被调用者函数的指令之间。

### 协程

协程通过将调用和返回操作中执行的一些步骤分离为三个额外操作：暂停、恢复和
销毁，将函数的操作概括化。

暂停操作在函数内的当前位置暂停协程的执行，并将执行权交还给调用者或恢复者
而不销毁活动帧。在协程执行暂停后，暂停点范围内的任何对象仍然保持活动状态。

注意，与函数的返回操作一样，协程之能在协程内部明确定义的暂停点处暂停。

恢复操作会在暂停点恢复恢复暂停的协程。这会重新激活协程的活动帧。

销毁操作会销毁活动帧，而不会恢复协程的执行。暂停点范围内的所有对象将被销毁，
用户存储活动帧的内存将被释放。

### 协程活动帧

既然协程可以在不销毁活动帧的前提下被挂起，那么我们可以不再保证活动帧的生命
周期严格嵌套。这意味着活动帧可以不用栈数据结构进行分配，可以存储在堆上。

c++协程TS中有一些规定，允许从调用者的活动帧中分配协程帧的内存，如果编译器
能证明协程的生命周期确实严格嵌套在调用者的生命周期内。如果您有一个足够智能
的编译器，这可以在很多情况下避免对内存分配。

对于协程来说，活动帧的某些部分需要在协程挂起期间保留，而有些部分只需要在协程
执行时保留。例如，具有不跨越任何协程挂起点范围的变量可以存储在栈上。

你可以逻辑上认为协程的活动帧由两部分组成：协程帧和栈帧。

“协程帧”保存了协程活动帧的一部分，这部分在协程挂起时会持续存在，而”栈帧“部分
仅在协程执行时存在，并在协程挂起并将执行权转回给调用者或恢复者时被释放。

### “暂停”操作

协程的暂停操作允许协程在函数中间暂停执行，并将执行交还给协程的调用者或恢复者。

协程函数体中的某些点被指定为暂停点。在c++协程TS中，这些暂停点通过co_await
或co_yield关键字来标识。

当协程到达其中一个暂停点时，它首先通过以下方式准备恢复协程：
- 确保寄存器中保存的所有值都写入协程帧。
- 向协程帧写入一个值，指示协程在哪个暂停点被暂停。这样，后续的恢复操作就可以
知道在哪里恢复协程的执行，或者后续的销毁操作就可以知道哪些值在范围内并且需要
销毁。

一旦协程准备好恢复，该协程就被视为“暂停”。

然后，协程就有机会在执行转移回调用者/恢复者之前执行一些额外的逻辑。此附加逻辑
可以访问协程帧的句柄，句柄可以被用于稍后恢复或销毁协程帧。

这种在协程进入“挂起”状态后执行逻辑的English，使得协程可以被调度恢复，而无需
执行同步。如果在协程进入“挂起”状态之前就进行恢复调度，可能会因为协程挂起和恢复
的竞态条件而需要同步处理。关于这一点，我将在以后的文章中详细说明。

协程可以选择立即恢复/继续执行协程，也可以选择将执行权转回给调用者或恢复者。

如果执行权被转回给调用者或恢复者，协程活动帧中的栈帧部分将被释放并弹栈。

### “恢复”操作

可以对当前处于“暂停”状态的协程执行恢复操作。

当一个函数想要恢复协程时，它需要有效地“调用”到该函数某次调用的中间部分。恢复者
通过调用协程帧句柄上的 void resume() 方法来标识要恢复的具体调用，该句柄是由对应
的挂起操作提供的。

就像普通的函数调用一样，这次对 resume() 的调用会分配一个新的栈帧，并在栈帧中存储
调用者的返回地址，然后将执行权转移到函数中。

然而，与普通函数不同的是，执行权并不会转移到函数的开头，而是跳转到函数上次挂起的
地方。它通过从协程帧中加载恢复点并跳转到该位置来实现这一点。

当协程下一次挂起或执行完成时，这次对 resume() 的调用将返回，并恢复调用函数的执行。

### 销毁操作

销毁操作销毁协程帧而不恢复协程的执行。

这个操作只能在挂起状态的协程上执行。

Destroy 操作的行为与 Resume 操作类似，它会重新激活协程的活动帧，包括分配一个新的
栈帧并存储调用 Destroy 操作的调用者的返回地址。

然而，与 Resume 操作不同的是，执行权不回转移到协程体的上一个挂起点，而是转移到一个
备用代码路径上，该路径会调用挂起点试所有在作用域内的局部变量的析构函数，然后释放协程
帧占用的内存。

与 Resume 操作类似，Destroy 操作通过调用协程句柄上的 void destroy() 方法，来
标识要销毁的具体活动帧，这个句柄是在对应的挂起操作期间提供的。

### 协程的“调用”操作

协程的调用操作与普通函数的调用操作非常相似，实际上，从调用者的角度来看，它们没有任何
区别。

然而，不同之处在于，普通函数只有在执行完成后才将执行权返回给调用者，而协程的调用操作
则会在协程到达第一个挂起点时恢复调用者的执行。

当对协程执行调用操作时，调用者会分配一个新的栈帧，将参数写入栈帧，将返回地址写入栈帧，
然后将执行权转移给协程。这与普通函数完全相同。

协程首先会在堆上分配一个协程帧，并将参数从栈帧复制或移动到协程帧中，以确保这些参数的
生命周期可以延续到第一个挂起点之后。

### 协程的“返回”操作

协程的返回操作与普通函数的返回操作稍有不同。

当协程执行返回语句(根据技术规范为 co_return 操作)时，它会将返回值存储在某个地方（
具体存储在哪里可以由协程自定义），然后析构所有在作用域内的局部变量（但不析构参数）。

协程接下来可以执行一些附加的逻辑，然后再将执行权转移回给调用者或恢复者。








